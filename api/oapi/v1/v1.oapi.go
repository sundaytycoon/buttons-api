// Package v1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.1 DO NOT EDIT.
package v1

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

// Defines values for BannedKeywordStatus.
const (
	BannedKeywordStatusACTIVE BannedKeywordStatus = "ACTIVE"

	BannedKeywordStatusDELETED BannedKeywordStatus = "DELETED"

	BannedKeywordStatusINACTIVE BannedKeywordStatus = "INACTIVE"
)

// Defines values for BannedKeywordTypeStatus.
const (
	BannedKeywordTypeStatusACTIVE BannedKeywordTypeStatus = "ACTIVE"

	BannedKeywordTypeStatusDELETED BannedKeywordTypeStatus = "DELETED"

	BannedKeywordTypeStatusINACTIVE BannedKeywordTypeStatus = "INACTIVE"
)

// Defines values for WordStatus.
const (
	WordStatusACTIVE WordStatus = "ACTIVE"

	WordStatusDELETED WordStatus = "DELETED"

	WordStatusINACTIVE WordStatus = "INACTIVE"
)

// words by banned_keyword.type
type BannedKeyword struct {
	// banned keyword by type table
	BannedKeywordType BannedKeywordType `json:"banned_keyword_type"`

	// The time the livestream was created.
	CreatedAt string `json:"created_at"`

	// The time the livestream was created.
	CreatedBy string `json:"created_by"`

	// The unique identifer of the livestream.
	Id int64 `json:"id"`

	// pure string
	Status BannedKeywordStatus `json:"status"`

	// The time the livestream was created.
	UpdatedAt string `json:"updated_at"`

	// The time the livestream was created.
	UpdatedBy string `json:"updated_by"`

	// a Keyword
	Word Word `json:"word"`
}

// pure string
type BannedKeywordStatus string

// banned keyword by type table
type BannedKeywordType struct {
	// The time the livestream was created.
	CreatedAt string `json:"created_at"`

	// The time the livestream was created.
	CreatedBy string `json:"created_by"`

	// The unique identifer of the livestream.
	Id int64 `json:"id"`

	// leave some comments
	Memo string `json:"memo"`

	// pure string
	Status BannedKeywordTypeStatus `json:"status"`

	// defined a relation name about banned keywords
	Type string `json:"type"`

	// The time the livestream was created.
	UpdatedAt string `json:"updated_at"`

	// The time the livestream was created.
	UpdatedBy string `json:"updated_by"`

	// type에 연결되어있는 words의 갯수
	WordsCount int64 `json:"words_count"`
}

// pure string
type BannedKeywordTypeStatus string

// a Keyword
type Word struct {
	// The time the livestream was created.
	CreatedAt string `json:"created_at"`

	// The time the livestream was created.
	CreatedBy string `json:"created_by"`

	// The unique identifer of the livestream.
	Id int64 `json:"id"`

	// pure string
	Name string `json:"name"`

	// pure string
	Status WordStatus `json:"status"`

	// The time the livestream was created.
	UpdatedAt string `json:"updated_at"`

	// The time the livestream was created.
	UpdatedBy string `json:"updated_by"`
}

// pure string
type WordStatus string

// BannedKeywordId defines model for banned_keyword_id.
type BannedKeywordId int64

// BannedKeywordTypeId defines model for banned_keyword_type_id.
type BannedKeywordTypeId int64

// BannedKeywordTypeType defines model for banned_keyword_type_type.
type BannedKeywordTypeType string

// HeaderAuditAction defines model for header_audit_action.
type HeaderAuditAction string

// HeaderAuditResource defines model for header_audit_resource.
type HeaderAuditResource string

// QueryFilterBannedKeywordTypeId defines model for query_filter_banned_keyword_type_id.
type QueryFilterBannedKeywordTypeId int64

// QueryFrom defines model for query_from.
type QueryFrom string

// QueryPaginationOffset defines model for query_pagination_offset.
type QueryPaginationOffset int64

// QueryPaginationQ defines model for query_pagination_q.
type QueryPaginationQ string

// QueryPaginationSize defines model for query_pagination_size.
type QueryPaginationSize int64

// QueryPaginationStatus defines model for query_pagination_status.
type QueryPaginationStatus string

// QuerySortCreatedAt defines model for query_sort_created_at.
type QuerySortCreatedAt string

// QuerySortName defines model for query_sort_name.
type QuerySortName string

// QueryType defines model for query_type.
type QueryType string

// GetBannedKeywordTypesParams defines parameters for GetBannedKeywordTypes.
type GetBannedKeywordTypesParams struct {
	// query filter by type
	Type *QueryType `json:"type,omitempty"`
}

// PostBannedKeywordTypesJSONBody defines parameters for PostBannedKeywordTypes.
type PostBannedKeywordTypesJSONBody BannedKeywordType

// PostBannedKeywordTypesParams defines parameters for PostBannedKeywordTypes.
type PostBannedKeywordTypesParams struct {
	// what did it
	XAuditAction *HeaderAuditAction `json:"X-Audit-Action,omitempty"`

	// what kind of the target
	XAuditResource *HeaderAuditResource `json:"X-Audit-Resource,omitempty"`
}

// GetBannedKeywordTypesListParams defines parameters for GetBannedKeywordTypesList.
type GetBannedKeywordTypesListParams struct {
	// query filter pagination offset
	Offset *QueryPaginationOffset `json:"offset,omitempty"`

	// query, filter pagination size
	Size *QueryPaginationSize `json:"size,omitempty"`

	// query filter pagination status
	Status *QueryPaginationStatus `json:"status,omitempty"`

	// query filter pagination q
	Q *QueryPaginationQ `json:"q,omitempty"`
}

// PatchBannedKeywordTypesBannedKeywordTypeIdJSONBody defines parameters for PatchBannedKeywordTypesBannedKeywordTypeId.
type PatchBannedKeywordTypesBannedKeywordTypeIdJSONBody BannedKeywordType

// PatchBannedKeywordTypesBannedKeywordTypeIdParams defines parameters for PatchBannedKeywordTypesBannedKeywordTypeId.
type PatchBannedKeywordTypesBannedKeywordTypeIdParams struct {
	// what did it
	XAuditAction *HeaderAuditAction `json:"X-Audit-Action,omitempty"`

	// what kind of the target
	XAuditResource *HeaderAuditResource `json:"X-Audit-Resource,omitempty"`
}

// PostBannedKeywordsJSONBody defines parameters for PostBannedKeywords.
type PostBannedKeywordsJSONBody BannedKeyword

// PostBannedKeywordsParams defines parameters for PostBannedKeywords.
type PostBannedKeywordsParams struct {
	// what did it
	XAuditAction *HeaderAuditAction `json:"X-Audit-Action,omitempty"`

	// what kind of the target
	XAuditResource *HeaderAuditResource `json:"X-Audit-Resource,omitempty"`
}

// PatchBannedKeywordsBulkJSONBody defines parameters for PatchBannedKeywordsBulk.
type PatchBannedKeywordsBulkJSONBody struct {
	Ids *[]int64 `json:"ids,omitempty"`
}

// PatchBannedKeywordsBulkParams defines parameters for PatchBannedKeywordsBulk.
type PatchBannedKeywordsBulkParams struct {
	// what did it
	XAuditAction *HeaderAuditAction `json:"X-Audit-Action,omitempty"`

	// what kind of the target
	XAuditResource *HeaderAuditResource `json:"X-Audit-Resource,omitempty"`
}

// PostBannedKeywordsBulkJSONBody defines parameters for PostBannedKeywordsBulk.
type PostBannedKeywordsBulkJSONBody struct {
	List *[]BannedKeyword `json:"list,omitempty"`
}

// PostBannedKeywordsBulkParams defines parameters for PostBannedKeywordsBulk.
type PostBannedKeywordsBulkParams struct {
	// what did it
	XAuditAction *HeaderAuditAction `json:"X-Audit-Action,omitempty"`

	// what kind of the target
	XAuditResource *HeaderAuditResource `json:"X-Audit-Resource,omitempty"`
}

// PostBannedKeywordsBulkIfNotExistJSONBody defines parameters for PostBannedKeywordsBulkIfNotExist.
type PostBannedKeywordsBulkIfNotExistJSONBody struct {
	List *[]BannedKeyword `json:"list,omitempty"`
}

// PostBannedKeywordsBulkIfNotExistParams defines parameters for PostBannedKeywordsBulkIfNotExist.
type PostBannedKeywordsBulkIfNotExistParams struct {
	// what did it
	XAuditAction *HeaderAuditAction `json:"X-Audit-Action,omitempty"`

	// what kind of the target
	XAuditResource *HeaderAuditResource `json:"X-Audit-Resource,omitempty"`
}

// GetBannedKeywordsListParams defines parameters for GetBannedKeywordsList.
type GetBannedKeywordsListParams struct {
	// query, filter banned_keyword_type_id
	BannedKeywordTypeId QueryFilterBannedKeywordTypeId `json:"banned_keyword_type_id"`

	// query, filter pagination size
	Size *QueryPaginationSize `json:"size,omitempty"`

	// query filter pagination offset
	Offset *QueryPaginationOffset `json:"offset,omitempty"`

	// query filter sort name
	SortName *QuerySortName `json:"sort_name,omitempty"`

	// query filter sort created_at
	SortCreatedAt *QuerySortCreatedAt `json:"sort_created_at,omitempty"`
}

// DeleteBannedKeywordsBannedKeywordIdParams defines parameters for DeleteBannedKeywordsBannedKeywordId.
type DeleteBannedKeywordsBannedKeywordIdParams struct {
	// what did it
	XAuditAction *HeaderAuditAction `json:"X-Audit-Action,omitempty"`

	// what kind of the target
	XAuditResource *HeaderAuditResource `json:"X-Audit-Resource,omitempty"`
}

// GetCachedBannedKeywordsTypeBannedKeywordTypeTypeParams defines parameters for GetCachedBannedKeywordsTypeBannedKeywordTypeType.
type GetCachedBannedKeywordsTypeBannedKeywordTypeTypeParams struct {
	// query filter pagination offset
	From *QueryFrom `json:"from,omitempty"`
}

// PostBannedKeywordTypesJSONRequestBody defines body for PostBannedKeywordTypes for application/json ContentType.
type PostBannedKeywordTypesJSONRequestBody PostBannedKeywordTypesJSONBody

// PatchBannedKeywordTypesBannedKeywordTypeIdJSONRequestBody defines body for PatchBannedKeywordTypesBannedKeywordTypeId for application/json ContentType.
type PatchBannedKeywordTypesBannedKeywordTypeIdJSONRequestBody PatchBannedKeywordTypesBannedKeywordTypeIdJSONBody

// PostBannedKeywordsJSONRequestBody defines body for PostBannedKeywords for application/json ContentType.
type PostBannedKeywordsJSONRequestBody PostBannedKeywordsJSONBody

// PatchBannedKeywordsBulkJSONRequestBody defines body for PatchBannedKeywordsBulk for application/json ContentType.
type PatchBannedKeywordsBulkJSONRequestBody PatchBannedKeywordsBulkJSONBody

// PostBannedKeywordsBulkJSONRequestBody defines body for PostBannedKeywordsBulk for application/json ContentType.
type PostBannedKeywordsBulkJSONRequestBody PostBannedKeywordsBulkJSONBody

// PostBannedKeywordsBulkIfNotExistJSONRequestBody defines body for PostBannedKeywordsBulkIfNotExist for application/json ContentType.
type PostBannedKeywordsBulkIfNotExistJSONRequestBody PostBannedKeywordsBulkIfNotExistJSONBody

// ServerInterface represents all server handler.
type ServerInterface interface {
	// get banned_keyword_type by type value
	// (GET /banned_keyword_types)
	GetBannedKeywordTypes(w http.ResponseWriter, r *http.Request, params GetBannedKeywordTypesParams)
	// add stopword
	// (POST /banned_keyword_types)
	PostBannedKeywordTypes(w http.ResponseWriter, r *http.Request, params PostBannedKeywordTypesParams)
	// get banned keywords
	// (GET /banned_keyword_types/list)
	GetBannedKeywordTypesList(w http.ResponseWriter, r *http.Request, params GetBannedKeywordTypesListParams)
	// banned_keyword의 row를 id대로 단 하나만 가져옵니다.
	// (GET /banned_keyword_types/{banned_keyword_type_id})
	GetBannedKeywordTypesBannedKeywordTypeId(w http.ResponseWriter, r *http.Request, bannedKeywordTypeId BannedKeywordTypeId)
	// banned_keyword 의 row를 수정합니다.
	// (PATCH /banned_keyword_types/{banned_keyword_type_id})
	PatchBannedKeywordTypesBannedKeywordTypeId(w http.ResponseWriter, r *http.Request, bannedKeywordTypeId BannedKeywordTypeId, params PatchBannedKeywordTypesBannedKeywordTypeIdParams)
	// banned_keyword에 type에 대한 단어를 등록합니다.
	// (POST /banned_keywords)
	PostBannedKeywords(w http.ResponseWriter, r *http.Request, params PostBannedKeywordsParams)
	// banned_keyword에 단어 여러개를 동시에 삭제합니다.
	// (PATCH /banned_keywords/bulk)
	PatchBannedKeywordsBulk(w http.ResponseWriter, r *http.Request, params PatchBannedKeywordsBulkParams)
	// banned_keyword에 단어 여러개를 동시에 넣습니다.
	// (POST /banned_keywords/bulk)
	PostBannedKeywordsBulk(w http.ResponseWriter, r *http.Request, params PostBannedKeywordsBulkParams)
	// banned_keyword에 단어 여러개를 동시에 넣습니다.
	// (POST /banned_keywords/bulk_if_not_exist)
	PostBannedKeywordsBulkIfNotExist(w http.ResponseWriter, r *http.Request, params PostBannedKeywordsBulkIfNotExistParams)
	// banned_keyword에 대한 단어목록들을 가져옵니다.
	// (GET /banned_keywords/list)
	GetBannedKeywordsList(w http.ResponseWriter, r *http.Request, params GetBannedKeywordsListParams)
	// typeBannedKeyword에 대한 수정을 합니다
	// (DELETE /banned_keywords/{banned_keyword_id})
	DeleteBannedKeywordsBannedKeywordId(w http.ResponseWriter, r *http.Request, bannedKeywordId BannedKeywordId, params DeleteBannedKeywordsBannedKeywordIdParams)
	// 금지어로 등록된 단어 하나를 가져옵니다.
	// (GET /banned_keywords/{banned_keyword_id})
	GetBannedKeywordsBannedKeywordId(w http.ResponseWriter, r *http.Request, bannedKeywordId BannedKeywordId)
	// banned_keyword의 목록들을 type로 가져옵니다.
	// (GET /cached/banned_keywords/type/{banned_keyword_type_type})
	GetCachedBannedKeywordsTypeBannedKeywordTypeType(w http.ResponseWriter, r *http.Request, bannedKeywordTypeType BannedKeywordTypeType, params GetCachedBannedKeywordsTypeBannedKeywordTypeTypeParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// GetBannedKeywordTypes operation middleware
func (siw *ServerInterfaceWrapper) GetBannedKeywordTypes(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBannedKeywordTypesParams

	// ------------- Optional query parameter "type" -------------
	if paramValue := r.URL.Query().Get("type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "type", r.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetBannedKeywordTypes(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostBannedKeywordTypes operation middleware
func (siw *ServerInterfaceWrapper) PostBannedKeywordTypes(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostBannedKeywordTypesParams

	headers := r.Header

	// ------------- Optional header parameter "X-Audit-Action" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Audit-Action")]; found {
		var XAuditAction HeaderAuditAction
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Audit-Action", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Audit-Action", runtime.ParamLocationHeader, valueList[0], &XAuditAction)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Audit-Action", Err: err})
			return
		}

		params.XAuditAction = &XAuditAction

	}

	// ------------- Optional header parameter "X-Audit-Resource" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Audit-Resource")]; found {
		var XAuditResource HeaderAuditResource
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Audit-Resource", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Audit-Resource", runtime.ParamLocationHeader, valueList[0], &XAuditResource)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Audit-Resource", Err: err})
			return
		}

		params.XAuditResource = &XAuditResource

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostBannedKeywordTypes(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetBannedKeywordTypesList operation middleware
func (siw *ServerInterfaceWrapper) GetBannedKeywordTypesList(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBannedKeywordTypesListParams

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "size" -------------
	if paramValue := r.URL.Query().Get("size"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "size", r.URL.Query(), &params.Size)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "size", Err: err})
		return
	}

	// ------------- Optional query parameter "status" -------------
	if paramValue := r.URL.Query().Get("status"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "q" -------------
	if paramValue := r.URL.Query().Get("q"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "q", r.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "q", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetBannedKeywordTypesList(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetBannedKeywordTypesBannedKeywordTypeId operation middleware
func (siw *ServerInterfaceWrapper) GetBannedKeywordTypesBannedKeywordTypeId(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "banned_keyword_type_id" -------------
	var bannedKeywordTypeId BannedKeywordTypeId

	err = runtime.BindStyledParameter("simple", false, "banned_keyword_type_id", chi.URLParam(r, "banned_keyword_type_id"), &bannedKeywordTypeId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "banned_keyword_type_id", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetBannedKeywordTypesBannedKeywordTypeId(w, r, bannedKeywordTypeId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PatchBannedKeywordTypesBannedKeywordTypeId operation middleware
func (siw *ServerInterfaceWrapper) PatchBannedKeywordTypesBannedKeywordTypeId(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "banned_keyword_type_id" -------------
	var bannedKeywordTypeId BannedKeywordTypeId

	err = runtime.BindStyledParameter("simple", false, "banned_keyword_type_id", chi.URLParam(r, "banned_keyword_type_id"), &bannedKeywordTypeId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "banned_keyword_type_id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchBannedKeywordTypesBannedKeywordTypeIdParams

	headers := r.Header

	// ------------- Optional header parameter "X-Audit-Action" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Audit-Action")]; found {
		var XAuditAction HeaderAuditAction
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Audit-Action", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Audit-Action", runtime.ParamLocationHeader, valueList[0], &XAuditAction)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Audit-Action", Err: err})
			return
		}

		params.XAuditAction = &XAuditAction

	}

	// ------------- Optional header parameter "X-Audit-Resource" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Audit-Resource")]; found {
		var XAuditResource HeaderAuditResource
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Audit-Resource", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Audit-Resource", runtime.ParamLocationHeader, valueList[0], &XAuditResource)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Audit-Resource", Err: err})
			return
		}

		params.XAuditResource = &XAuditResource

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PatchBannedKeywordTypesBannedKeywordTypeId(w, r, bannedKeywordTypeId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostBannedKeywords operation middleware
func (siw *ServerInterfaceWrapper) PostBannedKeywords(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostBannedKeywordsParams

	headers := r.Header

	// ------------- Optional header parameter "X-Audit-Action" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Audit-Action")]; found {
		var XAuditAction HeaderAuditAction
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Audit-Action", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Audit-Action", runtime.ParamLocationHeader, valueList[0], &XAuditAction)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Audit-Action", Err: err})
			return
		}

		params.XAuditAction = &XAuditAction

	}

	// ------------- Optional header parameter "X-Audit-Resource" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Audit-Resource")]; found {
		var XAuditResource HeaderAuditResource
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Audit-Resource", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Audit-Resource", runtime.ParamLocationHeader, valueList[0], &XAuditResource)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Audit-Resource", Err: err})
			return
		}

		params.XAuditResource = &XAuditResource

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostBannedKeywords(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PatchBannedKeywordsBulk operation middleware
func (siw *ServerInterfaceWrapper) PatchBannedKeywordsBulk(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchBannedKeywordsBulkParams

	headers := r.Header

	// ------------- Optional header parameter "X-Audit-Action" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Audit-Action")]; found {
		var XAuditAction HeaderAuditAction
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Audit-Action", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Audit-Action", runtime.ParamLocationHeader, valueList[0], &XAuditAction)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Audit-Action", Err: err})
			return
		}

		params.XAuditAction = &XAuditAction

	}

	// ------------- Optional header parameter "X-Audit-Resource" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Audit-Resource")]; found {
		var XAuditResource HeaderAuditResource
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Audit-Resource", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Audit-Resource", runtime.ParamLocationHeader, valueList[0], &XAuditResource)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Audit-Resource", Err: err})
			return
		}

		params.XAuditResource = &XAuditResource

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PatchBannedKeywordsBulk(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostBannedKeywordsBulk operation middleware
func (siw *ServerInterfaceWrapper) PostBannedKeywordsBulk(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostBannedKeywordsBulkParams

	headers := r.Header

	// ------------- Optional header parameter "X-Audit-Action" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Audit-Action")]; found {
		var XAuditAction HeaderAuditAction
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Audit-Action", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Audit-Action", runtime.ParamLocationHeader, valueList[0], &XAuditAction)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Audit-Action", Err: err})
			return
		}

		params.XAuditAction = &XAuditAction

	}

	// ------------- Optional header parameter "X-Audit-Resource" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Audit-Resource")]; found {
		var XAuditResource HeaderAuditResource
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Audit-Resource", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Audit-Resource", runtime.ParamLocationHeader, valueList[0], &XAuditResource)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Audit-Resource", Err: err})
			return
		}

		params.XAuditResource = &XAuditResource

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostBannedKeywordsBulk(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostBannedKeywordsBulkIfNotExist operation middleware
func (siw *ServerInterfaceWrapper) PostBannedKeywordsBulkIfNotExist(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostBannedKeywordsBulkIfNotExistParams

	headers := r.Header

	// ------------- Optional header parameter "X-Audit-Action" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Audit-Action")]; found {
		var XAuditAction HeaderAuditAction
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Audit-Action", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Audit-Action", runtime.ParamLocationHeader, valueList[0], &XAuditAction)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Audit-Action", Err: err})
			return
		}

		params.XAuditAction = &XAuditAction

	}

	// ------------- Optional header parameter "X-Audit-Resource" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Audit-Resource")]; found {
		var XAuditResource HeaderAuditResource
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Audit-Resource", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Audit-Resource", runtime.ParamLocationHeader, valueList[0], &XAuditResource)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Audit-Resource", Err: err})
			return
		}

		params.XAuditResource = &XAuditResource

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostBannedKeywordsBulkIfNotExist(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetBannedKeywordsList operation middleware
func (siw *ServerInterfaceWrapper) GetBannedKeywordsList(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBannedKeywordsListParams

	// ------------- Required query parameter "banned_keyword_type_id" -------------
	if paramValue := r.URL.Query().Get("banned_keyword_type_id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "banned_keyword_type_id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "banned_keyword_type_id", r.URL.Query(), &params.BannedKeywordTypeId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "banned_keyword_type_id", Err: err})
		return
	}

	// ------------- Optional query parameter "size" -------------
	if paramValue := r.URL.Query().Get("size"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "size", r.URL.Query(), &params.Size)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "size", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "sort_name" -------------
	if paramValue := r.URL.Query().Get("sort_name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sort_name", r.URL.Query(), &params.SortName)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort_name", Err: err})
		return
	}

	// ------------- Optional query parameter "sort_created_at" -------------
	if paramValue := r.URL.Query().Get("sort_created_at"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sort_created_at", r.URL.Query(), &params.SortCreatedAt)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort_created_at", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetBannedKeywordsList(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteBannedKeywordsBannedKeywordId operation middleware
func (siw *ServerInterfaceWrapper) DeleteBannedKeywordsBannedKeywordId(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "banned_keyword_id" -------------
	var bannedKeywordId BannedKeywordId

	err = runtime.BindStyledParameter("simple", false, "banned_keyword_id", chi.URLParam(r, "banned_keyword_id"), &bannedKeywordId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "banned_keyword_id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteBannedKeywordsBannedKeywordIdParams

	headers := r.Header

	// ------------- Optional header parameter "X-Audit-Action" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Audit-Action")]; found {
		var XAuditAction HeaderAuditAction
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Audit-Action", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Audit-Action", runtime.ParamLocationHeader, valueList[0], &XAuditAction)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Audit-Action", Err: err})
			return
		}

		params.XAuditAction = &XAuditAction

	}

	// ------------- Optional header parameter "X-Audit-Resource" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Audit-Resource")]; found {
		var XAuditResource HeaderAuditResource
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Audit-Resource", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Audit-Resource", runtime.ParamLocationHeader, valueList[0], &XAuditResource)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Audit-Resource", Err: err})
			return
		}

		params.XAuditResource = &XAuditResource

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteBannedKeywordsBannedKeywordId(w, r, bannedKeywordId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetBannedKeywordsBannedKeywordId operation middleware
func (siw *ServerInterfaceWrapper) GetBannedKeywordsBannedKeywordId(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "banned_keyword_id" -------------
	var bannedKeywordId BannedKeywordId

	err = runtime.BindStyledParameter("simple", false, "banned_keyword_id", chi.URLParam(r, "banned_keyword_id"), &bannedKeywordId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "banned_keyword_id", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetBannedKeywordsBannedKeywordId(w, r, bannedKeywordId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetCachedBannedKeywordsTypeBannedKeywordTypeType operation middleware
func (siw *ServerInterfaceWrapper) GetCachedBannedKeywordsTypeBannedKeywordTypeType(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "banned_keyword_type_type" -------------
	var bannedKeywordTypeType BannedKeywordTypeType

	err = runtime.BindStyledParameter("simple", false, "banned_keyword_type_type", chi.URLParam(r, "banned_keyword_type_type"), &bannedKeywordTypeType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "banned_keyword_type_type", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCachedBannedKeywordsTypeBannedKeywordTypeTypeParams

	// ------------- Optional query parameter "from" -------------
	if paramValue := r.URL.Query().Get("from"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "from", r.URL.Query(), &params.From)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "from", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCachedBannedKeywordsTypeBannedKeywordTypeType(w, r, bannedKeywordTypeType, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/banned_keyword_types", wrapper.GetBannedKeywordTypes)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/banned_keyword_types", wrapper.PostBannedKeywordTypes)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/banned_keyword_types/list", wrapper.GetBannedKeywordTypesList)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/banned_keyword_types/{banned_keyword_type_id}", wrapper.GetBannedKeywordTypesBannedKeywordTypeId)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/banned_keyword_types/{banned_keyword_type_id}", wrapper.PatchBannedKeywordTypesBannedKeywordTypeId)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/banned_keywords", wrapper.PostBannedKeywords)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/banned_keywords/bulk", wrapper.PatchBannedKeywordsBulk)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/banned_keywords/bulk", wrapper.PostBannedKeywordsBulk)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/banned_keywords/bulk_if_not_exist", wrapper.PostBannedKeywordsBulkIfNotExist)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/banned_keywords/list", wrapper.GetBannedKeywordsList)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/banned_keywords/{banned_keyword_id}", wrapper.DeleteBannedKeywordsBannedKeywordId)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/banned_keywords/{banned_keyword_id}", wrapper.GetBannedKeywordsBannedKeywordId)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/cached/banned_keywords/type/{banned_keyword_type_type}", wrapper.GetCachedBannedKeywordsTypeBannedKeywordTypeType)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"+b7ozn9AFbQOFreyVPlvAAAA//9Wq9vuMT0AAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
